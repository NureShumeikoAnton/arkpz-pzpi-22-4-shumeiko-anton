Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії




ЗВІТ
до практичної роботи №2 з дисципліни
"Аналіз та рефакторинг коду"
на тему: "Методи рефакторингу коду програмного забезпечення"




Виконав ст. гр. ПЗПІ-22-4
Шумейко Антон Олександрович

Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович








Харків 2024
МЕТА
Навчитись основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проєктів. Навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.

ВСТУП
Рефакторинг — це процес покращення внутрішньої структури коду без зміни його зовнішньої поведінки. Його метою є оптимізація коду для полегшення підтримки, розуміння та розширення проєкту. Отже, мета рефакторингу полянає у:
˗	Покращення читабельності та підтримуваності коду.
˗	Зменшення технічного боргу та запобігання накопиченню помилок.
˗	Полегшення адаптації проєкту до змін і розширення функціональності.
˗	Підвищення ефективності командної роботи завдяки зрозумілій та чистій структурі коду.
Далі розглянемо основні методи рефакторингу, їх приклади та застосування, а також особливості рефакторингу для Java.
Методами, що будуть розглянуті під час роботи є:
˗	Remove Control Flag
˗	Replace Temp with Query
˗	Encapsulate Field

ХІД РОБОТИ

	Назва методу: Remove Control Flag
	Опис: Часто в коді використовуються "керуючі" булеві змінні (флаги), які задають логіку виходу з циклу або виконання умов. Це може ускладнити розуміння коду та призвести до появи зайвих перевірок або переплутування логіки. Метод Remove Control Flag дозволяє видалити ці змінні та замінити їх на більш зрозумілі конструкції, такі як return, break, або continue.
	Метод допомагає прибрати зайві змінні-флаги та замінити їх на чіткі логічні операції, що робить код більш зрозумілим і скорочує кількість перевірок. Це підвищує читабельність і зменшує ймовірність помилок.
	Алгоритм рефакторингу:
1.	Визначити, де використовується контрольний прапорець.
2.	Замість прапорця застосувати прямий вихід з методу (return) або перервати виконання (break).
3.	Перевірити код на відповідність початковій функціональності після рефакторингу.
Приклад:

// поганий приклад
public class UserValidator1 {
    private boolean isValid;

    public boolean validateUser(String username, String password) {
        isValid = true;

        if (username == null || username.isEmpty()) {
            isValid = false;
        }

        if (password == null || password.length() < 8) {
            isValid = false;
        }

        if (isValid) {
            System.out.println("Користувач дійсний");
            return true;
        } else {
            System.out.println("Неправильний користувач");
            return false;
        }
    }
}

// гарний приклад
public class UserValidator2 {
    public boolean validateUser(String username, String password) {
        if (username == null || username.isEmpty()) {
            System.out.println("Неправильний користувач");
            return false;
        }

        if (password == null || password.length() < 8) {
            System.out.println("Неправильний користувач");
            return false;
        }

        System.out.println("Користувач дійсний");
        return true;
    }
}

У результаті рефакторингу код став більш лінійним і зрозумілим. Більше немає потреби відстежувати стан змінної isValid. Також використання прямих умовних операторів return дозволяє одразу побачити результат перевірки. Змінення логіки буде виконувати легше.

Назва методу: Replace Temp with Query
	Опис: У початковій версії коду тимчасові змінні використовуються для збереження проміжних результатів обчислень. Це може спричиняти проблеми з читабельністю, оскільки тимчасові змінні додають зайвий контекст, який потрібно тримати в пам'яті під час аналізу коду. Крім того, такі змінні обмежують гнучкість повторного використання логіки, адже значення, яке зберігається в змінній, недоступне за межами її області видимості. Метод Replace Temp with Query дозволяє вирішити ці проблеми шляхом перенесення обчислень у окремий метод. Це спрощує основний код, зменшує кількість проміжних змінних і робить логіку більш модульною.
	Алгоритм рефакторингу:
1.	Виділити обчислення тимчасових змінних у окремі методи.
2.	Замінити звернення до тимчасових змінних на виклики нових методів.
3.	Перевірити, що нові методи не порушують функціональність коду.
Приклад:

// поганий приклад
public class Order1 {
    private double itemPrice;
    private int quantity;

    public Order1(double itemPrice, int quantity) {
        this.itemPrice = itemPrice;
        this.quantity = quantity;
    }

    public double calculateTotal() {
        double basePrice = itemPrice * quantity; // Тимчасова змінна
        double discount = 0;

        if (basePrice > 100) {
            discount = basePrice * 0.1;
        }

        double finalPrice = basePrice - discount; // Тимчасова змінна
        return finalPrice;
    }
}

// гарний приклад
public class Order2 {
    private double itemPrice;
    private int quantity;

    public Order2(double itemPrice, int quantity) {
        this.itemPrice = itemPrice;
        this.quantity = quantity;
    }

    public double calculateTotal() {
        return getBasePrice() - getDiscount();
    }

    private double getBasePrice() {
        return itemPrice * quantity;
    }

    private double getDiscount() {
        return getBasePrice() > 100 ? getBasePrice() * 0.1 : 0;
    }
}

Після рефакторингу код став більш структурованим і модульним. Логіка обчислення базової ціни, знижки та доставки була винесена в окремі методи, що зробило основний метод calculateTotalPrice набагато зрозумілішим. Такий підхід дозволяє легко змінювати або розширювати логіку без ризику змінити поведінку основного коду. Окрім того, нові методи тепер можна повторно використовувати в інших частинах програми.


Назва методу: Encapsulate Field
Опис: Відкриті поля в класах можуть спричиняти низку проблем. По-перше, це порушує принцип інкапсуляції, адже внутрішній стан об'єкта стає доступним для прямого модифікування ззовні. Це робить код уразливим до помилок і ускладнює підтримку, оскільки не можна контролювати зміну значень цих полів. По-друге, відкриті поля унеможливлюють додавання логіки перевірки або обробки під час читання чи запису значення. Використання методу Encapsulate Field дозволяє вирішити ці проблеми, забезпечуючи доступ до полів через геттери та сеттери, що додає контроль і гнучкість.
Алгоритм рефакторингу:
1.	Змінити доступ до полів із public на private.
2.	Додати методи get і set для доступу до полів.
3.	Замінити всі прямі звернення до полів на виклики геттерів або сеттерів.
4.	За потреби додати логіку перевірки або обробки до геттерів і сеттерів.
Приклад:

// поганий приклад
public class Customer1 {
    public String name;
    public double balance;

    public Customer1(String name, double balance) {
        this.name = name;
        this.balance = balance;
    }
}

// гарний приклад
public class Customer2 {
    private String name;
    private double balance;

    public Customer2(String name, double balance) {
        this.name = name;
        this.balance = balance;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        } else {
            System.out.println("Ім'я не може бути порожнім.");
        }
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        if (balance >= 0) {
            this.balance = balance;
        } else {
            System.out.println("Баланс не може бути від'ємним.");
        }
    }
}

Рефакторинг значно покращив якість коду. Поля name і accountBalance тепер є приватними, а їхні значення змінюються через методи, які забезпечують контроль. Наприклад, додано перевірку для імені та позитивних значень під час додавання коштів. Це не тільки захищає дані від некоректного стану, але й робить код легшим для розширення та підтримки.



ІНСТРУМЕНТИ РЕФАКТОРИНГУ

	Сучасні середовища розробки пропонують потужні засоби для автоматизації рефакторингу, що дозволяє заощаджувати час та уникати помилок. Приклади інструментів рефакторингу наведено нижче:
1) JetBrains IntelliJ IDEA
˗	Автоматичне перейменування: дозволяє швидко перейменовувати змінні, методи, класи чи пакети, автоматично змінюючи всі посилання на ці об’єкти. Це зменшує ризик помилок та економить час.
˗	Переміщення методів та класів: інструмент дає змогу переміщувати методи між класами або навіть між пакетами, при цьому IntelliJ IDEA автоматично оновлює всі залежності та імпорти. Це корисно, коли потрібно реорганізувати структуру коду для кращого дотримання принципів OOP, наприклад, принципу єдиної відповідальності.
˗	Оптимізація імпортів: зайві або неактивні імпорти видаляються, а потрібні додаються автоматично. Це допомагає зберегти код чистим і уникнути конфліктів.
˗	Інкапсуляція полів: за допомогою одного інструмента можна змінити доступ до полів із public на private та автоматично створити геттери й сеттери. Це підвищує рівень інкапсуляції та безпеки даних у проєкті.
˗	Заміна тимчасових змінних на запити: цей метод дозволяє видалити проміжні змінні, якщо вони зайві, і замінити їх викликами методів, що робить код менш громіздким.
2) Eclipse
˗	Автоматичне перейменування: інструмент дозволяє змінювати назви змінних, методів, класів і пакетів, автоматично оновлюючи всі їх посилання.
˗	Виділення методу (Extract Method): допомагає створити новий метод із частини існуючого коду. Це зменшує дублювання коду та робить його більш структурованим.
˗	Інкапсуляція полів: Eclipse дозволяє швидко змінити рівень доступу полів на private і створити відповідні геттери та сеттери.
˗	Об’єднання дублікатів (Inline): злиття зайвих змінних або методів без втрати функціональності. Це дозволяє уникнути зайвого ускладнення коду.
3) Visual Studio Code
˗	Автоматичне перейменування: завдяки підтримці TypeScript і JavaScript, VS Code дозволяє легко змінювати назви змінних, функцій і класів із автоматичним оновленням усіх їхніх посилань у проєкті.
˗	Переміщення файлів і оновлення імпортів: коли ви переміщуєте файл до іншої директорії, VS Code автоматично оновлює всі імпорти в проєкті. Це значно спрощує реорганізацію коду.
˗	Інтеграція з лінтерами та форматувальниками: завдяки ESLint, Prettier та подібним інструментам можна автоматично виправляти стилістичні та структурні проблеми коду. Це особливо корисно при стандартних операціях, як видалення зайвих пробілів або дублювання рядків.

ВИСНОВКИ

	Рефакторинг є невід’ємною частиною розробки програмного забезпечення, яка спрямована на покращення якості коду без зміни його функціональності. У ході роботи було детально розглянуто три методи рефакторингу: Remove Control Flag, Replace Temp with Query та Encapsulate Field. Для кожного з методів були визначені проблеми, які вони вирішують, кроки їхнього впровадження та наведено приклади до і після рефакторингу. Це дозволило продемонструвати, як правильно використання цих методів може зробити код більш читабельним, структурованим та легким у підтримці.
Також під час виконання роботи начився використовувати сучасні інструменти рефакторингу, такі як JetBrains IntelliJ IDEA, Eclipse та Visual Studio Code. Кожен із них пропонує унікальні можливості для полегшення процесу рефакторингу, зокрема автоматичне перейменування, інкапсуляцію полів, оптимізацію імпортів тощо. Використання цих інструментів дозволяє не лише економити час, але й уникати людських помилок під час складних змін у структурі коду.
Таким чином, у процесі роботи вдалося глибше зрозуміти, як рефакторинг сприяє покращенню проєктів у довгостроковій перспективі. Ця практика дозволяє підтримувати код на високому рівні якості, забезпечуючи легкість його читання та подальшого розширення.
Посилання на відеозвіт з практичного заняття: https://youtu.be/SCEPgxjTZyQ
 
СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

	1. Роберт М. Clean Code: A Handbook of Agile Software Craftsmanship. 2024. 448 с.
	2. Фаулер М. Refactoring: Improving the Design of Existing Code. 2nd Edition. Addison-Wesley, 2018. 464 с.

 
Додаток А
Презентація
«Методи рефакторингу програмного забезпечення»